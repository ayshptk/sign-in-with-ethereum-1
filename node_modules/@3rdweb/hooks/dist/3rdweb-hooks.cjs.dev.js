'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@web3-react/core');
var React = require('react');
var providers = require('@ethersproject/providers');
var invariant = require('tiny-invariant');
var units = require('@ethersproject/units');
var injectedConnector = require('@web3-react/injected-connector');

function _interopDefault (e) { return e && e.__esModule ? e : { 'default': e }; }

function _interopNamespace(e) {
  if (e && e.__esModule) return e;
  var n = Object.create(null);
  if (e) {
    Object.keys(e).forEach(function (k) {
      if (k !== 'default') {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function () { return e[k]; }
        });
      }
    });
  }
  n["default"] = e;
  return Object.freeze(n);
}

var React__default = /*#__PURE__*/_interopDefault(React);
var invariant__default = /*#__PURE__*/_interopDefault(invariant);

function getLibrary(provider) {
  return new providers.Web3Provider(provider, "any");
}

const ThirdwebContext = /*#__PURE__*/React.createContext({
  _inProvider: false,
  connectors: {},
  supportedChainIds: []
});
function useThirdwebContext() {
  const context = React.useContext(ThirdwebContext);
  invariant__default["default"](context._inProvider, `
    Attempting to call useThirdwebContext from outside <ThirdwebProvider>, 
    did you forget to wrap your application in a <ThirdwebProvider>? 
  `);
  return context;
}
const ThirdwebWeb3Provider = ({
  connectors,
  supportedChainIds,
  networkMetadata,
  chainAddConfig,
  children
}) => {
  return /*#__PURE__*/React__default["default"].createElement(ThirdwebContext.Provider, {
    value: {
      _inProvider: true,
      connectors,
      supportedChainIds,
      networkMetadata,
      chainAddConfig
    }
  }, /*#__PURE__*/React__default["default"].createElement(core.Web3ReactProvider, {
    getLibrary: getLibrary
  }, children));
};

const defaultChainAddConfig = {
  1: {
    chainId: `0x${Number(1).toString(16)}`,
    chainName: "Mainnet",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://main-light.eth.linkpool.io/"]
  },
  4: {
    chainId: `0x${Number(4).toString(16)}`,
    chainName: "Rinkeby (ETH Testnet)",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby-light.eth.linkpool.io/"]
  },
  137: {
    chainId: `0x${Number(137).toString(16)}`,
    chainName: "Polygon Mainnet (Matic)",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com"],
    blockExplorerUrls: ["https://polygonscan.com"]
  },
  250: {
    chainId: `0x${Number(250).toString(16)}`,
    chainName: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18
    },
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorerUrls: ["https://ftmscan.com"]
  },
  43114: {
    chainId: `0x${Number(43114).toString(16)}`,
    chainName: "Avalanche Mainnet C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorerUrls: ["https://cchain.explorer.avax.network"]
  },
  80001: {
    chainId: `0x${Number(80001).toString(16)}`,
    chainName: "Polygon Mumbai Testnet",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://rpc-mumbai.maticvigil.com", "https://rpc-mumbai.matic.today"],
    blockExplorerUrls: ["https://mumbai.polygonscan.com"]
  }
};
function useSwitchNetwork() {
  const {
    chainAddConfig
  } = useThirdwebContext();
  const {
    account,
    library,
    connector,
    chainId
  } = core.useWeb3React();
  const [isSwitching, setIsSwitching] = React.useState(false);
  const [switchError, setSwitchError] = React.useState();
  const [connectorProvider, setConnectorProvider] = React.useState();
  React.useEffect(() => {
    const getProvider = async () => {
      setConnectorProvider(await connector?.getProvider());
    };

    if (connector) {
      getProvider();
    }
  }, [connector]);
  React.useEffect(() => {
    setSwitchError(null);
  }, [chainId, account]);
  const canAttemptSwitch = React.useMemo(() => {
    return !!connectorProvider?.request;
  }, [connectorProvider?.request]);
  const switchNetwork = React.useCallback(async newChainId => {
    if (!connectorProvider?.request) {
      setSwitchError(new Error("No provider available to switch"));
      return;
    }

    setSwitchError(null);

    if (newChainId === chainId) {
      return;
    }

    setIsSwitching(true);
    const chainHex = `0x${newChainId.toString(16)}`;

    try {
      await connectorProvider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: chainHex
        }]
      });
    } catch (_switchError) {
      if (_switchError.code === 4902 && chainAddConfig && chainAddConfig[newChainId]) {
        try {
          await connectorProvider.request({
            method: "wallet_addEthereumChain",
            params: [chainAddConfig[newChainId]]
          });
        } catch (addError) {
          setSwitchError(addError);
        }
      } else if (_switchError.code === 4902 && defaultChainAddConfig[newChainId]) {
        try {
          await connectorProvider.request({
            method: "wallet_addEthereumChain",
            params: [defaultChainAddConfig[newChainId]]
          });
        } catch (addError) {
          setSwitchError(addError);
        }
      } else {
        setSwitchError(_switchError);
      }
    } finally {
      setIsSwitching(false);
    }
  }, [chainAddConfig, connectorProvider, chainId]);
  return {
    switchNetwork,
    canAttemptSwitch,
    isSwitching,
    switchError
  };
}

function useConnectWallet() {
  const {
    activate
  } = core.useWeb3React();
  const {
    connectors,
    supportedChainIds
  } = useThirdwebContext();
  return React.useCallback(async (connectorType, connectOptions) => {
    invariant__default["default"](connectors[connectorType], `
        Invalid connect() call for connector: ${connectorType}. 
        This connector is not defined on the <ThirdwebContext>.
      `);
    const connectorOptions = connectors[connectorType] ? { ...connectors[connectorType],
      supportedChainIds
    } : {
      supportedChainIds
    };

    switch (connectorType) {
      case "injected":
        {
          const {
            InjectedConnector
          } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/injected-connector')); });
          return await activate(new InjectedConnector(connectorOptions));
        }

      case "magic":
        {
          const {
            MagicConnector
          } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/magic-connector')); });
          const {
            email
          } = connectOptions;
          const _connectorOptions = connectors[connectorType];
          return await activate(new MagicConnector({ ..._connectorOptions,
            email
          }));
        }

      case "walletlink":
        {
          const {
            WalletLinkConnector
          } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/walletlink-connector')); });
          return await activate(new WalletLinkConnector(connectorOptions));
        }

      case "walletconnect":
        {
          const {
            WalletConnectConnector
          } = await Promise.resolve().then(function () { return /*#__PURE__*/_interopNamespace(require('@web3-react/walletconnect-connector')); });
          return await activate(new WalletConnectConnector(connectorOptions));
        }

      default:
        throw new Error(`Unsupported connector: ${connectorType}`);
    }
  }, [connectors, supportedChainIds, activate]);
}

const defaultNetworkMetadata = {
  1: {
    chainName: "Ethereum",
    iconUrl: "https://ethereum.org/static/4b5288012dc4b32ae7ff21fccac98de1/31987/eth-diamond-black-gray.png",
    symbol: "ETH",
    isTestnet: false
  },
  4: {
    chainName: "Rinkeby",
    iconUrl: "https://ethereum.org/static/4b5288012dc4b32ae7ff21fccac98de1/31987/eth-diamond-black-gray.png",
    symbol: "ETH",
    isTestnet: true
  },
  137: {
    chainName: "Polygon",
    iconUrl: "https://s2.coinmarketcap.com/static/img/coins/64x64/3890.png",
    symbol: "MATIC",
    isTestnet: false
  },
  250: {
    chainName: "Fantom",
    iconUrl: "https://icodrops.com/wp-content/uploads/2018/04/teryT6Hw_400x400.jpg",
    symbol: "FTM",
    isTestnet: false
  },
  43114: {
    chainName: "Avalanche",
    iconUrl: "https://assets.website-files.com/6059b554e81c705f9dd2dd32/60ec6a944b52e3e96e16af68_Avalanche_Square_Red_Circle.png",
    symbol: "AVAX",
    isTestnet: false
  },
  80001: {
    chainName: "Mumbai",
    iconUrl: "https://s2.coinmarketcap.com/static/img/coins/64x64/3890.png",
    symbol: "MATIC",
    isTestnet: true
  }
};
function useWeb3() {
  const connect = useConnectWallet();
  const {
    connectors,
    networkMetadata
  } = useThirdwebContext();
  const web3Context = core.useWeb3React();
  const {
    library,
    connector,
    account,
    error,
    chainId,
    deactivate
  } = web3Context;
  const [balance, setBalance] = React.useState();
  React.useEffect(() => {
    if (error?.message.includes("The user rejected the request.")) {
      deactivate();
    }
  }, [error, deactivate]);
  React.useEffect(() => {
    const checkInjected = async () => {
      const injected = new injectedConnector.InjectedConnector({});

      if (await injected.isAuthorized()) {
        connect("injected");
      }
    };

    setTimeout(() => {
      checkInjected();
    }, 500);
  }, [connect]);
  React.useEffect(() => {
    const getBalance = async () => {
      if (account) {
        const accountBalance = await library?.getBalance(account);
        setBalance({
          value: accountBalance,
          formatted: units.formatEther(accountBalance || 0).slice(0, 6)
        });
      } else {
        setBalance({
          formatted: "0.0"
        });
      }
    };

    getBalance();
  }, [library, account]);
  const activeProvider = React.useMemo(() => {
    return library?.provider;
  }, [library?.provider]);
  const disconnectWallet = React.useCallback(async () => {
    const provider = activeProvider;

    if (!provider) {
      return;
    }

    if (provider.isMetaMask && provider.request) {
      const request = await provider.request({
        method: "wallet_requestPermissions",
        params: [{
          eth_accounts: {}
        }]
      });
      return request;
    } else {
      if (connector && connector.close) {
        connector.close();
        return;
      }

      return deactivate();
    }
  }, [activeProvider, connector, deactivate]);
  const getNetworkMetadata = React.useCallback(_chainId => {
    return networkMetadata && networkMetadata[_chainId] || defaultNetworkMetadata[_chainId] || {
      chainName: "",
      iconUrl: "",
      symbol: ""
    };
  }, [networkMetadata]);
  return React.useMemo(() => ({
    error,
    chainId,
    connector,
    balance,
    provider: library,
    activeProvider,
    // Force no null account
    address: account || undefined,
    connectors: Object.keys(connectors),
    connectWallet: connect,
    disconnectWallet,
    getNetworkMetadata
  }), [account, chainId, balance, connector, activeProvider, connect, connectors, disconnectWallet, getNetworkMetadata, error, library]);
}

exports.ThirdwebWeb3Provider = ThirdwebWeb3Provider;
exports.useSwitchNetwork = useSwitchNetwork;
exports.useThirdwebContext = useThirdwebContext;
exports.useWeb3 = useWeb3;
