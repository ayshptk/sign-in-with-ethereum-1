import { Web3ReactProvider, useWeb3React } from '@web3-react/core';
import React, { useContext, createContext, useState, useEffect, useMemo, useCallback } from 'react';
import { Web3Provider } from '@ethersproject/providers';
import invariant from 'tiny-invariant';
import { formatEther } from '@ethersproject/units';
import { InjectedConnector } from '@web3-react/injected-connector';

function getLibrary(provider) {
  return new Web3Provider(provider, "any");
}

const ThirdwebContext = /*#__PURE__*/createContext({
  _inProvider: false,
  connectors: {},
  supportedChainIds: []
});
function useThirdwebContext() {
  const context = useContext(ThirdwebContext);
  invariant(context._inProvider, `
    Attempting to call useThirdwebContext from outside <ThirdwebProvider>, 
    did you forget to wrap your application in a <ThirdwebProvider>? 
  `);
  return context;
}
const ThirdwebWeb3Provider = ({
  connectors,
  supportedChainIds,
  networkMetadata,
  chainAddConfig,
  children
}) => {
  return /*#__PURE__*/React.createElement(ThirdwebContext.Provider, {
    value: {
      _inProvider: true,
      connectors,
      supportedChainIds,
      networkMetadata,
      chainAddConfig
    }
  }, /*#__PURE__*/React.createElement(Web3ReactProvider, {
    getLibrary: getLibrary
  }, children));
};

const defaultChainAddConfig = {
  1: {
    chainId: `0x${Number(1).toString(16)}`,
    chainName: "Mainnet",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://main-light.eth.linkpool.io/"]
  },
  4: {
    chainId: `0x${Number(4).toString(16)}`,
    chainName: "Rinkeby (ETH Testnet)",
    nativeCurrency: {
      name: "Ethereum",
      symbol: "ETH",
      decimals: 18
    },
    rpcUrls: ["https://rinkeby-light.eth.linkpool.io/"]
  },
  137: {
    chainId: `0x${Number(137).toString(16)}`,
    chainName: "Polygon Mainnet (Matic)",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://polygon-rpc.com"],
    blockExplorerUrls: ["https://polygonscan.com"]
  },
  250: {
    chainId: `0x${Number(250).toString(16)}`,
    chainName: "Fantom Opera",
    nativeCurrency: {
      name: "Fantom",
      symbol: "FTM",
      decimals: 18
    },
    rpcUrls: ["https://rpc.ftm.tools"],
    blockExplorerUrls: ["https://ftmscan.com"]
  },
  43114: {
    chainId: `0x${Number(43114).toString(16)}`,
    chainName: "Avalanche Mainnet C-Chain",
    nativeCurrency: {
      name: "Avalanche",
      symbol: "AVAX",
      decimals: 18
    },
    rpcUrls: ["https://api.avax.network/ext/bc/C/rpc"],
    blockExplorerUrls: ["https://cchain.explorer.avax.network"]
  },
  80001: {
    chainId: `0x${Number(80001).toString(16)}`,
    chainName: "Polygon Mumbai Testnet",
    nativeCurrency: {
      name: "Matic",
      symbol: "MATIC",
      decimals: 18
    },
    rpcUrls: ["https://rpc-mumbai.maticvigil.com", "https://rpc-mumbai.matic.today"],
    blockExplorerUrls: ["https://mumbai.polygonscan.com"]
  }
};
function useSwitchNetwork() {
  const {
    chainAddConfig
  } = useThirdwebContext();
  const {
    account,
    library,
    connector,
    chainId
  } = useWeb3React();
  const [isSwitching, setIsSwitching] = useState(false);
  const [switchError, setSwitchError] = useState();
  const [connectorProvider, setConnectorProvider] = useState();
  useEffect(() => {
    const getProvider = async () => {
      setConnectorProvider(await connector?.getProvider());
    };

    if (connector) {
      getProvider();
    }
  }, [connector]);
  useEffect(() => {
    setSwitchError(null);
  }, [chainId, account]);
  const canAttemptSwitch = useMemo(() => {
    return !!connectorProvider?.request;
  }, [connectorProvider?.request]);
  const switchNetwork = useCallback(async newChainId => {
    if (!connectorProvider?.request) {
      setSwitchError(new Error("No provider available to switch"));
      return;
    }

    setSwitchError(null);

    if (newChainId === chainId) {
      return;
    }

    setIsSwitching(true);
    const chainHex = `0x${newChainId.toString(16)}`;

    try {
      await connectorProvider.request({
        method: "wallet_switchEthereumChain",
        params: [{
          chainId: chainHex
        }]
      });
    } catch (_switchError) {
      if (_switchError.code === 4902 && chainAddConfig && chainAddConfig[newChainId]) {
        try {
          await connectorProvider.request({
            method: "wallet_addEthereumChain",
            params: [chainAddConfig[newChainId]]
          });
        } catch (addError) {
          setSwitchError(addError);
        }
      } else if (_switchError.code === 4902 && defaultChainAddConfig[newChainId]) {
        try {
          await connectorProvider.request({
            method: "wallet_addEthereumChain",
            params: [defaultChainAddConfig[newChainId]]
          });
        } catch (addError) {
          setSwitchError(addError);
        }
      } else {
        setSwitchError(_switchError);
      }
    } finally {
      setIsSwitching(false);
    }
  }, [chainAddConfig, connectorProvider, chainId]);
  return {
    switchNetwork,
    canAttemptSwitch,
    isSwitching,
    switchError
  };
}

function useConnectWallet() {
  const {
    activate
  } = useWeb3React();
  const {
    connectors,
    supportedChainIds
  } = useThirdwebContext();
  return useCallback(async (connectorType, connectOptions) => {
    invariant(connectors[connectorType], `
        Invalid connect() call for connector: ${connectorType}. 
        This connector is not defined on the <ThirdwebContext>.
      `);
    const connectorOptions = connectors[connectorType] ? { ...connectors[connectorType],
      supportedChainIds
    } : {
      supportedChainIds
    };

    switch (connectorType) {
      case "injected":
        {
          const {
            InjectedConnector
          } = await import('@web3-react/injected-connector');
          return await activate(new InjectedConnector(connectorOptions));
        }

      case "magic":
        {
          const {
            MagicConnector
          } = await import('@web3-react/magic-connector');
          const {
            email
          } = connectOptions;
          const _connectorOptions = connectors[connectorType];
          return await activate(new MagicConnector({ ..._connectorOptions,
            email
          }));
        }

      case "walletlink":
        {
          const {
            WalletLinkConnector
          } = await import('@web3-react/walletlink-connector');
          return await activate(new WalletLinkConnector(connectorOptions));
        }

      case "walletconnect":
        {
          const {
            WalletConnectConnector
          } = await import('@web3-react/walletconnect-connector');
          return await activate(new WalletConnectConnector(connectorOptions));
        }

      default:
        throw new Error(`Unsupported connector: ${connectorType}`);
    }
  }, [connectors, supportedChainIds, activate]);
}

const defaultNetworkMetadata = {
  1: {
    chainName: "Ethereum",
    iconUrl: "https://ethereum.org/static/4b5288012dc4b32ae7ff21fccac98de1/31987/eth-diamond-black-gray.png",
    symbol: "ETH",
    isTestnet: false
  },
  4: {
    chainName: "Rinkeby",
    iconUrl: "https://ethereum.org/static/4b5288012dc4b32ae7ff21fccac98de1/31987/eth-diamond-black-gray.png",
    symbol: "ETH",
    isTestnet: true
  },
  137: {
    chainName: "Polygon",
    iconUrl: "https://s2.coinmarketcap.com/static/img/coins/64x64/3890.png",
    symbol: "MATIC",
    isTestnet: false
  },
  250: {
    chainName: "Fantom",
    iconUrl: "https://icodrops.com/wp-content/uploads/2018/04/teryT6Hw_400x400.jpg",
    symbol: "FTM",
    isTestnet: false
  },
  43114: {
    chainName: "Avalanche",
    iconUrl: "https://assets.website-files.com/6059b554e81c705f9dd2dd32/60ec6a944b52e3e96e16af68_Avalanche_Square_Red_Circle.png",
    symbol: "AVAX",
    isTestnet: false
  },
  80001: {
    chainName: "Mumbai",
    iconUrl: "https://s2.coinmarketcap.com/static/img/coins/64x64/3890.png",
    symbol: "MATIC",
    isTestnet: true
  }
};
function useWeb3() {
  const connect = useConnectWallet();
  const {
    connectors,
    networkMetadata
  } = useThirdwebContext();
  const web3Context = useWeb3React();
  const {
    library,
    connector,
    account,
    error,
    chainId,
    deactivate
  } = web3Context;
  const [balance, setBalance] = useState();
  useEffect(() => {
    if (error?.message.includes("The user rejected the request.")) {
      deactivate();
    }
  }, [error, deactivate]);
  useEffect(() => {
    const checkInjected = async () => {
      const injected = new InjectedConnector({});

      if (await injected.isAuthorized()) {
        connect("injected");
      }
    };

    setTimeout(() => {
      checkInjected();
    }, 500);
  }, [connect]);
  useEffect(() => {
    const getBalance = async () => {
      if (account) {
        const accountBalance = await library?.getBalance(account);
        setBalance({
          value: accountBalance,
          formatted: formatEther(accountBalance || 0).slice(0, 6)
        });
      } else {
        setBalance({
          formatted: "0.0"
        });
      }
    };

    getBalance();
  }, [library, account]);
  const activeProvider = useMemo(() => {
    return library?.provider;
  }, [library?.provider]);
  const disconnectWallet = useCallback(async () => {
    const provider = activeProvider;

    if (!provider) {
      return;
    }

    if (provider.isMetaMask && provider.request) {
      const request = await provider.request({
        method: "wallet_requestPermissions",
        params: [{
          eth_accounts: {}
        }]
      });
      return request;
    } else {
      if (connector && connector.close) {
        connector.close();
        return;
      }

      return deactivate();
    }
  }, [activeProvider, connector, deactivate]);
  const getNetworkMetadata = useCallback(_chainId => {
    return networkMetadata && networkMetadata[_chainId] || defaultNetworkMetadata[_chainId] || {
      chainName: "",
      iconUrl: "",
      symbol: ""
    };
  }, [networkMetadata]);
  return useMemo(() => ({
    error,
    chainId,
    connector,
    balance,
    provider: library,
    activeProvider,
    // Force no null account
    address: account || undefined,
    connectors: Object.keys(connectors),
    connectWallet: connect,
    disconnectWallet,
    getNetworkMetadata
  }), [account, chainId, balance, connector, activeProvider, connect, connectors, disconnectWallet, getNetworkMetadata, error, library]);
}

export { ThirdwebWeb3Provider, useSwitchNetwork, useThirdwebContext, useWeb3 };
